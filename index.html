<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ðŸŒŸ A1 Interactive Word Search ðŸŒŸ</title>
  <style>
    body {
      font-family: 'Comic Sans MS', cursive;
      background-color: #fff9ec;
      text-align: center;
      padding: 20px;
    }
    h1 {
      color: #ff6f61;
    }
    #grid {
      margin: 20px auto;
      border-collapse: collapse;
    }
    #grid td {
      width: 40px;
      height: 40px;
      text-align: center;
      font-size: 24px;
      border: 2px solid #ffc97b;
      cursor: pointer;
      transition: background 0.2s;
      user-select: none;
    }
    #grid td.selected {
      background-color: #ffe169;
    }
    #grid td.found {
      background-color: #90ee90;
    }
    .word-list {
      margin-top: 20px;
      font-size: 18px;
      color: #555;
    }
    .found-word {
      text-decoration: line-through;
      color: green;
    }
    .instructions {
      font-size: 16px;
      color: #444;
      margin-bottom: 10px;
    }
    #victory {
      font-size: 24px;
      color: #ff6f61;
      margin-top: 20px;
      display: none;
    }
    input#words {
      text-transform: uppercase;
    }
  </style>
</head>
<body>

  <h1>ðŸŒŸ A1 Interactive Word Search ðŸŒŸ</h1>
  <p class="instructions">
    Enter <b>4 words (max 8 letters each)</b>.<br>
    Words can appear <b>up, down, left, right, or diagonally</b>.<br>
    Click and drag to find words!
  </p>

  <input type="text" id="words" placeholder="e.g. SUN, CAT, TREE, BOOK" style="width:300px; font-size:18px;">
  <button onclick="generate()">Generate Word Search</button>

  <table id="grid"></table>
  <div class="word-list" id="wordlist"></div>
  <div id="victory">ðŸŽ‰ Well Done! You found all the words! ðŸŽ‰</div>

  <script>
    document.getElementById('words').addEventListener('input', e => {
      e.target.value = e.target.value.toUpperCase();
    });

    let gridData = [];
    let selectedCells = [];
    let isMouseDown = false;
    let words = [];
    const size = 8;  // 8x8 board for A1 level
    let selectionDirection = null;

    const directions = [
      [ 1,  0], [-1,  0],  // vertical
      [ 0,  1], [ 0, -1],  // horizontal
      [ 1,  1], [-1, -1],  // main diagonal
      [ 1, -1], [-1,  1]   // anti-diagonal
    ];

    function generate() {
      document.getElementById('victory').style.display = "none";
      const input = document.getElementById('words').value;
      words = input.split(',').map(w => w.trim()).filter(Boolean);

      if (words.length !== 4) {
        alert("Please enter exactly 4 words separated by commas.");
        return;
      }
      for (let w of words) {
        if (w.length > 8) {
          alert(`"${w}" is too long! Max 8 letters.`);
          return;
        }
      }

      gridData = Array.from({ length: size }, () => Array(size).fill(''));

      for (let w of words) {
        let placed = false;
        for (let tries = 0; tries < 200 && !placed; tries++) {
          const [dx, dy] = directions[Math.floor(Math.random() * directions.length)];
          const row = Math.floor(Math.random() * size);
          const col = Math.floor(Math.random() * size);
          if (canPlaceWord(w, row, col, dx, dy)) {
            placeWord(w, row, col, dx, dy);
            placed = true;
          }
        }
      }

      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (!gridData[r][c]) {
            gridData[r][c] = letters[Math.floor(Math.random() * letters.length)];
          }
        }
      }

      renderGrid();
      document.getElementById('wordlist').innerHTML =
        "Find: " + words.map(w => `<span id=\"word-${w}\">${w}</span>`).join(', ');
    }

    function canPlaceWord(word, row, col, dx, dy) {
      let r = row, c = col;
      for (let i = 0; i < word.length; i++) {
        if (r < 0 || r >= size || c < 0 || c >= size) return false;
        if (gridData[r][c] && gridData[r][c] !== word[i]) return false;
        r += dx; c += dy;
      }
      return true;
    }

    function placeWord(word, row, col, dx, dy) {
      let r = row, c = col;
      for (let i = 0; i < word.length; i++) {
        gridData[r][c] = word[i];
        r += dx; c += dy;
      }
    }

    function renderGrid() {
      const table = document.getElementById('grid');
      table.innerHTML = '';
      for (let r = 0; r < size; r++) {
        const tr = document.createElement('tr');
        for (let c = 0; c < size; c++) {
          const td = document.createElement('td');
          td.textContent = gridData[r][c];
          td.dataset.row = r;
          td.dataset.col = c;
          td.addEventListener('mousedown', startSelection);
          td.addEventListener('mouseover', dragSelection);
          td.addEventListener('mouseup', endSelection);
          tr.appendChild(td);
        }
        table.appendChild(tr);
      }
      document.body.addEventListener('mouseup', () => isMouseDown = false);
    }

    function startSelection(e) {
      clearSelection();
      isMouseDown = true;
      selectionDirection = null;
      selectCell(e.target);
    }

    function dragSelection(e) {
      if (isMouseDown) selectCell(e.target);
    }

    function endSelection() {
      isMouseDown = false;
      checkSelection();
    }

    function selectCell(cell) {
      if (!cell.dataset.row || cell.classList.contains('selected')) return;
      const r = +cell.dataset.row, c = +cell.dataset.col;

      if (selectedCells.length === 0) {
        cell.classList.add('selected');
        selectedCells.push(cell);
        return;
      }

      const first = selectedCells[0];
      const fr = +first.dataset.row, fc = +first.dataset.col;
      const last = selectedCells[selectedCells.length - 1];
      const lr = +last.dataset.row, lc = +last.dataset.col;

      if (!selectionDirection) {
        const dr = r - fr, dc = c - fc;
        if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1 && (dr !== 0 || dc !== 0)) {
          selectionDirection = [Math.sign(dr), Math.sign(dc)];
        } else return;
      }

      const [dx, dy] = selectionDirection;
      if (r === lr + dx && c === lc + dy) {
        cell.classList.add('selected');
        selectedCells.push(cell);
      }
    }

    function clearSelection() {
      selectedCells.forEach(c => c.classList.remove('selected'));
      selectedCells = [];
      selectionDirection = null;
    }

    function checkSelection() {
      if (!selectedCells.length) return;
      const str = selectedCells.map(c => c.textContent).join('');
      const rev = str.split('').reverse().join('');
      let found = null;
      if (words.includes(str)) found = str;
      else if (words.includes(rev)) found = rev;

      if (found) {
        selectedCells.forEach(c => {
          c.classList.remove('selected');
          c.classList.add('found');
        });
        document.getElementById('word-' + found).classList.add('found-word');
        checkVictory();
      } else {
        clearSelection();
      }
    }

    function checkVictory() {
      const all = words.every(w =>
        document.getElementById('word-' + w).classList.contains('found-word')
      );
      if (all) document.getElementById('victory').style.display = "block";
    }
  </script>

</body>
</html>
